# Week 12

Subject 1: Dynamic Programming 활용

### 최장 증가 수열

- 어떤 수열이 왼쪽에서 오른쪽으로 나열되어 있을 때, 배열된 순서를 유지하면서 크기가 점진적으로 커지는 가장 긴 부분 수열의 길이를 찾는 방법
    - 부분 수열에 포함되는 요소들이 순서상 연속적일 필요는 없음

1. 완전 검색 적용
    1. 수열의 모든 부분 집합을 구하여 각 부분 집합이 증가 수열이 되는지 판별
    2. 증가 수열이 되는 수열 중 가장 길이가 긴 수열을 찾음
    - 부분 수열의 길이가 긴 것부터 조사하는 것이 유리
    
    ```java
    // S : 수열
    FOR i in N -> 1
    		FOR ALL subsequence of S with legth of 
    					IF there is one increasing subsequence // 증가 수열인지 조사
    						BREAK
    ```
    

1. 다른 방법
    1. 수열 $a_1, a_2, ~a_n$ 
    2. LIS(i) :  $a_1, a_2, ~a_n$에 존재하는 최장 증가 부분 수열의 길이
    3. i보다 길이가 작은 수열들에 존재하는 최장 증가 수열의 길이 : LIS(1), LIS(2), ... , LIS(i-1)
    - Case1 : LIS(i)가 $a_i$를 포함하지 않는다면, LIS(i) = LIS(i-1)
    - Case2 : LIS(i)가 $a_i$를 포함한다면, LIS(i) = ?
        - $a_i$ 바로 전에 위치하는 요소를 찾음
        - 증가 수열의 관계인 $a_j < a_i$인 $a_j$ 찾기 (j<i)
        - j 값을 알 수 없으므로 모두 검색
        - 그 중 최대값을 찾아 1 증가시켜 LIS(i)에 저장
            - LIS(i) = 1 + max LIS(j) (j<i and $a_j < a_i$
        - LIS() 중에서 최대값을 찾음
    - 각 요소로 끝나는 최장 증가 수열들 중 가장 긴 수열 : 최장 증가 수열
        
        → 각 요소로 끝나는 최장 증가 수열들을 모두 계산하면 해결
        
    
    ```java
    // LIS[i] : a_i로 끝나는 최장 증가 수열의 길이 저장
    FOR i in 1 -> n
    		LIS[i] = 1
    		FOR j in 1 -> i-1
    				IF a_j < a_i AND 1 + LIS[j] > LIS[i]
    						LIS[i] = 1 + LIS[j]
    RETURN max LIS[]
    // 시간 복잡도 : O(n^2)
    ```
    
    1. 이진 검색을 이용
        1. C[k] : 길이 k의 증가 수열에 대하여 가장 작은 값을 C[k]에 저장
        2. 각 위치에서 C[]를 갱신하기 위해 이진 탐색 수행
        - 수열의 요소 값을 하나씩 읽어와 C배열의 범위를 벗어나는 값 : 마지막에 추가
        - 요소 값이 C 배열의 범위 안에 포함되는 값 : 자기보다 작은 값 다음 위치에 저장
        - 시간 복잡도 : O(nlogn)

### 모든 쌍 최단 경로 문제

- 가중치 유향 그래프에서 각 정점 사이의 최단 경로의 가중치 합은?
    - 최단 경로 문제 : 한 도시(정점)에서 다른 도시(정점)로 직항로가 없는 경우 가장 빨리 갈 수 있는 항로를 찾는 문제
    - 모든 쌍 최단 경로 문제 : 모든 도시들 사이에 가장 빨리 갈 수 있는 항로를 찾는 문제
        - 가중치 포함, 방향성 그래프 : 음의 가중치 허용. 가중치 합이 음인 싸이클을 허용하지 않음
        - 최적화 문제 : 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답을 찾아야 하는 문제

1. 고지식한(brute-force) 접근 방법
    1. 한 정점~다른 정점의 모든 경로의 길이를 구한 뒤, 그들 중 최소 길이를 찾음
    2. 가정 : n개의 정점을 가지는 완전 그래프
    3. 한 정점 i에서 다른 정점 j로 가는 모든 경로 중 정점 i, j를 제외한 나머지 모든 정점을 한번씩 꼭 거쳐서 가는 경로들의 수는?
    - i에서 출발하여 처음에 도착할 수 있는 정점의 가지 수 : n-2
        
        → 그 중 하나 선택 
        
        → 그 다음에 도착할 수 있는 정점의 가지 수 : n-3
        
        - 총 경로 수 : (n-2)(n-3)...1 = (n-2)! → 비효율적

1. 다른 방법
    1. 각 정점을 시작점으로 정하여 Dijkstra 알고리즘 수행
    2. 시간 복잡도 : O($n^2$) (배열 사용), O(elogn) (힙 사용)
        1. 모든 정점의 수 : n X 다익스트라 알고리즘(O($n^2$))
        2. n : 정점의 수, e : 간선의 수

1. 플로이드-워샬 알고리즘
    1. 시간복잡도 = O($n^3$)
    2. 매우 간단하고 다익스트라 알고리즘보다 효율적
    3. 동적 계획법을 적용하여 모든 쌍 최단 경로를 구하는 알고리즘
    - 정점 i~정점 j로 직접 가는 경로와 정점을 경유하는 경로 중 짧은 것 선택
    - 경유 가능한 점들을 하나씩 추가해 나가면서 최단 경로를 구함
    - 그래프의 정점 설정 : 1, 2, 3, ... , n
    - $D_{ij}^k$ : 정점 {1, 2, ..., k} 만을 경유 가능한 정점들을 고려하여, 정점 i~정점 j까지의 모든 경로 중 최단 경로의 가중치 합
    - k ≠ i, k ≠ j
    - k = 0 : 정점 0은 그래프에 없으므로 어떤 점도 경유하지 않음
        
        → $D_{ij}^0$ : 그래프에 포함된 간선 [i, j]의 가중치
        
    
    ```java
    // D[i][j] : i에서 j로 가는 최단 경로 가중치 합
    // 최초 D[i][j]에는 간선 (i, j)의 가중치 저장, i에서 j로 간선이 없으면 INF
    
    ALLPairsShortest(D[][])
    		FOR k in 1-> n
    				FOR i in 1 -> n
    						FOR j in 1 -> n
    								D[i][j] <- min(D[i][k] + D[k][j], D[i][j])
    ```
    

### 순회 외판원 문제(Traveling Salesman Problem)

- 휴가 기간에 어떤 방문 순서로 여행하면 모든 도시들을 여행하면서도 이동 경비가 최소가 될까? (집에서 출발하여 여행이 끝나면 집으로 돌아와야 함)
- 외판원이 자신의 집이 위치하고 있는 도시에서 출발해 다른 도시들을 각각 한번씩만 방문하고, 다시 자기 도시로 돌아오는 가장 짧은 일주여행경로(tour)를 결정하는 문제
    - 가중치가 있는 방향성 그래프 대상
    - 그래프 상의 일주여행경로 : 한 정점을 출발해 다른 모든 정점을 한번씩만 거쳐서 다시 그 정점으로 돌아오는 경로
    - 최적일주여행경로(optimal tour) : 여러 개의 일주여행경로 중 최소 길이 경로

1. 무작정 알고리즘
    1. 가능한 모든 일주여행경로를 다 고려한 후, 그 중 가장 짧은 일주여행경로 선택
    2. 가능한 일주여행경로의 총 개수 : (n-1)!개
    - 정점의 개수 증가 시 시간 복잡도 : O(n!)
    - 모든 일주여행경로 조사 방법 외 효율적인 다른 방법은 아직 없음
    - 동적 계획법 적용 → 작은 부분 문제의 최적해 산출 → 더 큰 부분 문제의 최적해 산출 : 중복 작업 감소 가능
    
2. 동적 계획법 기반 알고리즘
    1. V : 모든 정점의 집합, A : V의 부분집합
    2. D[$v_i$][A] : A에 속한 각 정점을 정확히 한번씩만 거쳐서 $v_i$에서 $v_1$로 가는 최단경로
    - 최적 일주여행경로의 길이
        
        $D[v_1][V-(v_1)]   = min_{2<=j<=n}(W[1][j] + D[v_j][V-(v_1, v_j)]$
        
    - 동적계획법 적용 알고리즘의 동작 과정
        - 정점 집합의 공집합 → 정점이 하나인 집합 → 두 개인 집합으로 증가 → 최종적으로 거쳐가는 정점이 n-2개일 때까지 계산
    - 알고리즘
        
        ```java
        // W[][] : 인접행렬, minlength : 최적일주여행경로의 가중치 합, n : 정점의 개수
        // D[][] : 부분문제의 해를 저장하기 위한 저장소, 2차 배열 아님
        
        travel(n, W[][])
        		// 각 정점의 시작 정점
        		// v_1을 뺀 나머지 정점들에 대한 모든 부분 집합들의 해 저장 가능 해야함
        		number D[1...n][subset of V - {v_1}]
        
        		// v_1을 뺀 나머지 정점을 시작점, 거쳐가는 정점이 공집합인 경우 
        		FOR i in 2 -> n
        				D[i][emptyset] <- W[i][1]
        
        		// k는 1부터 n-2까지 증가시키면서 반복 (k : 거쳐가는 정점 집합의 크기)
        		FOR k in 1 -> n-2
        				// v_1을 뺀 나머지 정점들의 집합에 원소의 수가 k개인 모든 부분집합에 대해 반복
        				FOR all subsets A  V-{v_1} containing k vertices
        						// v_1을 뺀 나머지 정점들을 각각 시작점 i로 선택하고
        						// i를 포함하지 않는 부분집합에 대해서만 반복
        						FOR i such that i 1 AND v_i ∈ A
        								// v_i를 시작점으로 거쳐가는 정점들의 집합 A에 대해 계산
        								// 집합 A에 포함된 원소의 수만큼 비교
        								D[i][A] <- minimumvj A(W[i][j] + D[v_j][A-{v_j}])
        
        		// 시작 정점 v_1로 하고 나머지 정점들을 거쳐가는 정점으로 고려하여 계산
        		D[1][V-{v_1}] <- minimum2 j n(W[1][j] + D[v_j][A-{v_1}])
        		minlength <- D[1][V-{v_1}]
        ```
        
    - 시간복잡도 : O($n^22^n$)
    - 공간복잡도 : O(n$2^n$)