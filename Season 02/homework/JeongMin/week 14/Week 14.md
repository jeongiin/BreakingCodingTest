# Week 14

## **문자열**

[사이트 바로가기](https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVuPDYSqAAbw5UW6&subjectId=AV5KmPTqDbUDFAXc)

### 해싱

- 특정 항목 검색 시, 탐색 키에 대한 산술적 연산으로 키가 있는 위치를 계산하여 바로 찾아가는 방법
- 자료의 크기에 상관없이 O(1)의 시간 복잡도를 가짐
    1. 직접 번지 테이블(배열)
    - 자료를 직접 번지 테이블에 저장
    - 전체 키들의 집합이 작은 경우 효율적
    
    → 키 값의 집합 U가 클 때, 현실적 컴퓨터 메모리공간에서 테이블 T 생성 불가능
    
    → 실제 키 집합 K가 U에 비해 상대적으로 작아서 T의 메모리 공간이 낭비됨
    
    1. 해시 테이블
    - 집합 U에 비해 실제로 사용되는 키들의 집합 K가 작은 경우 사용
    - 직접 번지 테이블보다 적은 메모리 공간 필요
    - 저장 공간 = O(|K|)
    - 해시 함수(h) : 키 값 k의 자료를 저장할 위치를 계산
        
        → 키 값이 k인 자료를 h(k)에 저장
        
    - 충돌(Collision) : 서로 다른 키 값을 해시 함수에 적용했을 때, 반환된 값이 동일한 경우
        
        → 자료의 수가 증가하면 충돌은 불가피
        
        - 체이닝(Chaining) : 해시 테이블의 구조를 변경해 각 버킷에 하나 이상의 키 값을 가지는 자료가 저장될 수 있도록 함
            
            → 연결리스트 활용
            
        - 개방 주소법(Open Addressing) : 해시 함수로 구한 주소에 빈공간이 없어 충돌이 발생하면, 그 다음 위치에 빈공간이 있는지 조사
            
            → 빈공간이 있으면 : 탐색키에 대한 항목 저장
            
            → 빈공간이 없으면 : 공간이 나올 때까지 탐색 반복
            

### 문자열 매칭(패턴 매칭)

- 텍스트 문자열(t)에 패턴 문자열(p)이 포함되어 있는지 찾는 것
- 단순한 검색 방법 : 고지식한 패턴 검색 알고리즘
    - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교하는 방식의 알고리즘
    - 불일치가 발생하는 경우 → 텍스트와 패턴의 새로운 시작 위치를 결정하는 것이 핵심
        - 텍스트의 시작은 이전 시작의 다음 위치
        - 패턴은 항상 처음에 시작
    
    ```java
    // p[] : 패턴, t[] : 텍스트
    // M : 패턴의 길이, N : 텍스트의 길이
    
    BruteForce(p[], t[])
    	i <- 0, j <- 0
    	// j = M 이면 패턴을 찾은 경우
    	// i = N 이면 패턴을 찾지 못한 경우
    	WHILE j < M AND i < N
    		IF t[i] != p[j]
    			i <- i - j
    			j <- -1;
    		i <- j + 1
    		j <- j + 1
    	IF j == M : RETURN i - M
    	ELSE : RETURN i
    ```
    
    - 시간 복잡도 : O(MN)
- 효율적 검색 방법
    1. 카프 - 라빈 알고리즘
    - 문자열 검색을 위해 해시 함수를 이용
    - 패턴의 해시 값과 텍스트 내의 패턴의 길이만큼의 문자열에 대한 해시 값 비교
    - 최악의 시간 복잡도 = O(MN)
    - 평균적으로 선형에 가까운 빠른 속도
    - 해시 값을 구할 때, 새로 추가되는 문자와 그 전에 계산한 값을 이용
        - ex : 6843 → 8432 일 경우, (6843-6*10^3)*10+2 = 8432
    - 고려 사항
        - 처음 해시 값을 구할 때, 찾고자 하는 문자열에서 패턴 길이만큼 읽어서 구함
        - 패턴의 길이가 커지면 길이를 일정 자릿수로 맞추기 위해 모듈러(Mod) 연산을 취해 줌
        - 해시 값이 일치할 경우 실제 문자열이 일치하는지 검사해야 함
        
    1. KMP 알고리즘(Knuth-Moris-Pratt)
    - 불일치가 발생한 텍스트 문자열의 앞에 어떤 문자가 있는지 알고 있으므로 다시 비교하지 않고 매칭 수행
    - 불일치가 발생 → 다음 비교 위치를 미리 계산, 불필요한 시작 최소화
    - 시간 복잡도 = O(M+N) (M:패턴의 길이, N:텍스트의 길이)
    
    ```java
    // p[] : 패턴, M : 패턴의 길이
    // next[] : 불일치가 발생하면 이동할 위치를 저장
    
    KMP_Preprocess(p[], next[])
    	i <- 0, j <- -1
    	// 패턴의 처음 위치에서 불일치 발생 시,
    	// 고지식한 패턴 검색과 유사하게 동작하기 위함
    	next[i] <- -1
    	
    	WHILE(i < M)
    		WHILE(j >= 0 && [i] != p[j])
    			j = next[j];
    		
    		// 같으면 계속 비교하기 위해 i와 j를 증가
    		// j : 지금까지 일치한 문자열의 개수
    		i <- i + 1, j <- j + 1
    		next[i] <- j
    ```
    
    ```java
    // t[] : 텍스트, N : 텍스트 길이
    // p[] : 패턴, M : 패턴 길이
    // next[] : 불일치가 발생하면 이동할 위치 저장
    
    KMP_Search(t[], p[], next[])
    	i = 0, j = 0
    	
    	WHILE(i < N)
    		WHILE(j >= 0 && t[i] != next[j])
    				j = next[j];
    		
    		i <- i + 1, j <- j + 1
    
    	// 패턴을 찾은 경우
    		if (j == M)
    			return i - j
    	
    	RETURN -1
    ```
    
    1. 보이어 - 무어 알고리즘
    - 오른쪽 끝에서 왼쪽으로 문자열을 비교 → 앞부분보다 끝부분에 불일치가 일어날 확률이 높은 성질 이용
    - 불일치가 일어났을 때 텍스트의 문자에 대해 얼마나 이동해야 하는지 미리 계산

- 알고리즘 비교
    - 찾고자 하는 패턴 길이 : m, 총 텍스트 길이 : n
    - 고지식, 카프-라빈, KMP → 시간 복잡도 = O(n)
    - 보이어-무어 → 최악의 경우 O(n), 입력에 따라 다르지만 일반적으로 O(n)보다 시간소요 적음

### 트라이(Trie)

- 문자열의 집합을 표현하는 트리(Tree)
- 트라이의 각 간선은 하나의 문자에 대응
- 같은 노드에서 나오는 간선들은 같은 라벨을 갖지 않음
- 루트 노드에서 단말 노드까지 이른 경로는 하나의 문자열
- 접미어 트라이 : 문자열의 모든 접미어를 트라이로 표현
- 접미어 트라이 활용
    - 부분 문자열 검사
        
        → 한 문자씩 루트에서 대응되는 간선 따라가기
        
    - 두 접미어의 최장 공통 접두어 찾기
        
        → 두 접미어의 끝 글자에 대응하는 노드 선택
        
        → 가장 가까운 공통 조상을 찾음
        
        → 공통 접두어를 만듦(루트에서 공통 조상까지의 경로)
        
    - 사전적 순서로 정렬된 k번째 접미어 찾기
        
        → 깊이 우선 탐색으로 생성하면 사전순으로 정렬
        
        → 생성된 문자열은 메모리에 저장하지 않고 인덱스 값만 저장
        
        → 보통 접미어 트라이의 단말 노드에 대응하는 접미어의 시작 위치를 저장
        
    

### 접미어 트리(Suffix Tree)

- 하나의 문자열의 모든 접미어를 포함하는 트라이(Trie)의 표현
- 압축된 트라이(Compressed Trie) : 노드와 간선을 부분 문자열로 압축
    - 하나의 노드를 하나의 간선으로 묶어 표현
- 길이 s인 문자열 S의 접미어 트리의 속성
    - 단말노드에는 접미어의 시작 위치를 저장
    - 루트를 제외한 내부 노드는 최소 2개의 자식을 가짐
    - 각 간선은 문자열 S의 부분문자열 라벨(Label)이 부여됨
    - 한 노드에서 나가는 두 개의 간선이 같은 문자로 시작하는 문자열 라벨을 가질 수 없음
    - 루트에서 단말 노드 i까지의 라벨을 연결하면 문자열 S의 i 위치부터 끝까지의 문자열이 됨
- 하나의 접미어가 다른 접미어의 접두어가 되는 경우
    - 문자열 끝에 특수한 문자를 추가
    - 일반적으로 $를 사용 ( $ : 종료문자, 가장 작은 값을 가지는 문자)
    - 간선에 부여된 라벨을 효과적으로 저장하기 위해 부분 문자열 T[i...j]의 인덱스 시작과 끝(i, j)를 저장할 수 있음
- 접미어 트리의 생성에 필요한 시간 = O($n^2$)
- 트라이의 압축된 형태이지만 여전히 메모리 많이 필요

### 접미어 배열

- 텍스트의 접미어를 사전적으로 나열한 배열
- 접미어 트리보다 메모리를 효율적으로 사용 but 다소 느림
- 사전순으로 정렬된 접미어들의 시작 인덱스 값을 차례로 저장
- 접미어 배열의 복잡도
    - 공간 복잡도 = O(n)
    - O(nlogn) 시간에 생성 가능
    - 텍스트 T에 패턴 P의 존재를 O(|P| + logn) 시간에 계산 가능
    - 사전순 정렬로 이분탐색을 적용하기에 효과적
- 접미어 배열의 장점
    - 생성 방법이 접미어 트리에 비해 간단
    - 적은 메모리 필요
- LCP 배열
    - 접미어 배열의 보조적 자료 구조
    - 최장 공통 접두어에 대한 정보를 저장
        
        → 정렬된 접미어 배열에서 연속적인 두 개의 접미어들 사이의 최장 공통 접두어의 길이를 저장
        

### 압축

- 압축 기법
    - Run-Length Encoding
    - Huffman Coding
    - Lampel-Ziv-Welch Encoding
    - Arithmetic Coding
- 인코딩(Encoding) : 데이터를 압축하는 것
- 디코딩(Decoding) : 데이터를 원래 상태로 복구하는 것
- 압축률 = C(D)의 비트 수 / D의 비트 수
    - D : 바이너리 데이터
    - C(D) : 압축 데이터
    - D’ : 복구된 원본(또는 근사)
- 무손실 압축 : 압축된 데이터를 디코딩했을 때 원본 데이터와 동일
- 손실 압축 : 디코딩시 원본 데이터에서 손실 발생
1. Run-Length Encoding
    - 동일한 값(코드)이 몇 번 반복 되는가를 나타냄
    - BMP 파일 포맷의 압축 방법
    - ex : A1 B7 C2 (A가 1개 연속, B가 7개 연속, C가 2개 연속)
    
    ```jsx
    // MAXCOUNT = 255
    RLEncoding(input[])
        // 연속적으로 나타나는 코드 값의 횟수 저장
        // 1~255까지 표현 가능
        count <- 1
        // 바로 전에 나온 코드 값 저장
        prev <- '\0
        WHILE input remains
            curr <- get next symbol
            IF prev = curr AND count < MAXCOUNT
                count = count + 1
            ELSE
                output(prev, count)
                count <- 1
            prev <- curr
        output(curr, count)
    ```
    
    - Run-Length Decoding 알고리즘
    
    ```jsx
    RLDecoding()
        curr, count
        WHILE input remains
            curr <- get symbol
            count <- get count
    
            WHILE count > 0
                output(cur)
                count = count - 1
    ```
    

1. 허프만 코드(Huffman Code)
- 기호의 빈도 : 전체 데이터 안에서 기호가 차지하는 비율
- 허프만 트리 : 각 기호에 이진 코드를 부여하기 위해 생성하는 트리
- 고정 길이 코드와 접두어 코드
    - 고정 길이 코드 : 기호에 대응하는 코드값의 길이가 똑같은 코드 체계
    - 접두어 코드(Prefix Code) : 가변 길이 코드의 한 종류로 어느 코드가 다른 코드의 접두어가 되지 않는 코드 체계 → 길이가 다른 코드값 구분 가능
- 허프만 코드의 생성
    - 탐욕 알고리즘 기법으로 생성
    - 노드 규칙 : 단말 노드는 기호와 빈도를 저장, 부모 노드는 빈도만 저장
    - 트리가 존재하지 않고 문자들에 대한 노드만 있다고 가정
        
        → 빈도수가 가장 작은 노드 2개 선택
        
        → 2개의 노드를 자식으로 하는 부모 노드 생성
        
        → 부모 노드의 빈도는 자식 노드의 빈도의 합임
        
        → 반복하다가 선택할 노드가 1개만 남으면 종료
        

## **투 포인터**

### **투 포인터란?**

- 리스트에 순차적으로 접근해야 할 때, 두 개의 점의 위치를 기록하면서 처리하는 알고리즘
    - ex : 정렬된 두 리스트의 합집합
- 예시 문제 : 특정 합을 가지는 부분 연속 수열 찾기
    - 어떤 숫자들의 리스트가 주어질 때, 해당 리스트의 연속 수열의 합이 특정 값을 가지는 것을 확인하는 문제
    - start : 부분 배열의 앞쪽을 가리키는 인덱스
    - end : 부분 배열의 뒤쪽을 가리키는 인덱스
    - 항상 start ≤ end 를 만족해야 함
    1. 시작점과 끝점이 첫 번째 원소의 인덱스를 가리키도록 함
    2. 현재 부분 합이 M과 같다면 카운트
    3. 현재 부분 합이 M보다 작다면 end를 1 증가
    4. 현재 부분 합이 M보다 크거나 같다면 start를 1 증가
    5. 모든 경우를 확인할 때까지 2~4를 반복
    - 시간 복잡도 : O(n)
    
    → 자연수이기 때문에 end가 증가하면 부분 합이 증가하고, start가 감소하면 부분 합이 감소하는 것을 보장할 수 있음
    
    → 음수가 섞여있다면 투 포인터를 사용할 수 없다!
    
- 슬라이딩 윈도우와 비교
    - 공통점 : 구간을 훑으면서 지나감
    - 차이점 : 슬라이딩 윈도우는 어느 순간에도 구간의 넓이가 동일함

### **문제 분석 및 풀이**

[1806번 문제](https://www.acmicpc.net/problem/1806)를 풀고, 왜 일반적인 방법으로는 풀어낼 수 없는지 정리해주세요

- 제한시간이 매우 짧으므로, 중첩 반복문을 사용하여 풀면 시간 초과가 발생한다!
- 투 포인터를 사용하여 풀이
    - 수열의 양 끝을 가리키는 인덱스 start, end를 설정
    - 부분합이 S 이상일 때, end-start+1(경우에 따라 end-start) 값과 이전에 구한 최소 수열 길이 값을 비교하여 더 작은 값으로 갱신

## **Greedy**

### **What is `Greedy Algorithm`?**

- Greedy Algorithm(탐욕 알고리즘) : 선택의 순간마다 눈 앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달하는 방법
- 순간마다 하는 선택은 지역적으로는 최적이지만, 그 선택들을 수집하여 최종 해답을 만들었다고 해서 그것이 최적이라는 보장은 없음
    
    → 탐욕 알고리즘을 적용할 수 있는 문제들은 지역적으로 최적이면서, 전역적으로 최적인 문제들
    
- 문제 해결 과정
    1. 선택 절차(Selection Procedure) : 현재 상태에서의 최적의 해답을 선택
    2. 적절성 검사(Feasibility Check) : 선택된 해가 문제의 조건을 만족하는지 검사
    3. 해답 검사(Solution Check)  : 원래의 문제가 해결되었는지 검사, 해결되지 않았다면 1로 돌아가 위 과정을 반복
- 조건
    1. 탐욕적 선택 속성(Greedy Choice Property) : 앞의 선택이 이후의 선택에 영향을 주지 않음
    2. 최적 부분 구조(Optimal Substructure) : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성됨
- 탐욕 알고리즘은 근사 알고리즘으로 사용 가능
    - 근사 알고리즘(Approximation Algorithm) : 어떤 최적화 문제에 대한 해의 근사값을 구하는 알고리즘
- 매트로이드 : 탐욕 알고리즘을 적용해도 언제나 최적해를 구할 수 있는 문제
    - 예시 : 4,040원 어치의 물건을 사려고 5000원을 지불할 때, 거스름돈 동전의 개수를 최소한으로 받고 싶다
    - 탐욕 알고리즘 적용
    1. 선택 절차 : 거스름돈의 동전 개수를 줄이기 위해 현재 가장 가치가 높은 동전을 우선 선택
    2. 적절성 검사 : 선택된 동전들의 합이 거슬러 줄 금액을 초과하는지 검사 → 초과한다면 가장 마지막에 선택한 동전을 삭제 후, 1로 돌아가 한 단계 작은 동전을 선택
    3. 해답 검사 : 선택된 동전들의 합이 거슬러 줄 금액과 일치하는지 검사 → 액수가 부족하면 1부터 다시 반복
- 예시 문제 : 활동 선택 문제
    - 한 강의실에서 여러 개의 수업을 하려고 할 때, 한 번에 가장 많은 수업을 할 수 있는 경우를 고르는 것
    - 수업 시작 시간($s_i$)과 수업 종료 시간($f_i$)이 주어짐
    - 최적해를 구하기 위해서는 가장 빨리 끝나는 수업을 골라야 함
    - $f_i$ 기준으로 오름차순 정렬 후 $s_i$로 정렬해야 그리디 알고리즘 적용 가능

### **What is `Brute-Force`**

- Brute(무식한) + Force(힘) : 완전 탐색 알고리즘으로 가능한 모든 경우의 수를 탐색하고 조건에 맞는 결과만 가져옴
- ‘해가 하나 이상 존재한다’ 라는 가정을 세우고 모든 영역을 탐색
- 선형 구조를 모두 탐색하는 방법 : 순차 탐색
- 비선형 구조를 모두 탐색하는 방법 : BFS, DFS
- 순차탐색
    - 방법
    1. 구조화 : 문제에서 주어진 자료를 선형 구조로 구조화
    2. 탐색 : 구조화된 자료들을 구조에 맞는 방법으로 해를 구할 때까지 탐색
    3. 정리 : 탐색한 해를 주어진 문제의 출력 형식에 맞게 정리
- 구현하기 쉽지만, 시간 면에서 매우 비효율적

### **문제 분석 및 풀이**

[1969 문제](https://www.acmicpc.net/problem/1969)를 풀고, 왜 완전탐색으로 풀 수 없는지 정리해주세요!

→ 수정 : 빛유진은 DFS를 이용해 문제를 풀기로 결심했다. 지금까지 공부해왔던 방식대로, 길이 M 의 DNA 문자열을 만들어 최소값의 Hamming Distance를 가지는 DNA를 답으로 도출하기로 했으나 제출시 시간초과가 이루어졌다. 이유가 뭘까?

- 4^(m-1)개의 정점을 탐색하게 되므로 시간 복잡도는 O(4^(M-1))
- 시작점이 각각 A, T, G, C 인 경우로 총 4가지 이므로 4 * O(4^(M-1)) = O(4^M)
- DNA의 수 N만큼 반복해야 하므로 N * O(4^M) = O(N * 4^M)
- M의 최대값인 50을 대입했을 때, 4^M = 4^50 = 2^100 이다. 이는 약 126양의 매우 큰 수이므로 시간초과가 발생!!! 양은 대충 1조의 다음다음다음다음 단계 큰 수..