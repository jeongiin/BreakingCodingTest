# Week 11

Subject 1: Dynamic Programming

## 다이나믹 프로그래밍

- **작은 부분에서 큰 부분**의 해들을 모두 구하여 최종적으로 원래 주어진 문제를 해결하는 설계 기법
- 하나의 문제는 단 한 번만 풀도록 하는 알고리즘
    - 큰 문제를 작은 문제로 나눌 수 있을 때
    - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일할 때
- 최적화 문제 해결
    - 최대값 또는 최소값을 구하는 문제
    - 여러 개의 최적해 중 임의의 최적해 하나를 찾는 것
- 효율적 완전 검색
- 재귀 + 메모이제이션
- 문제를 분석해 재귀적으로 정의하고 수식 형태로 표현해 점화식을 찾음
- 적용 요건
    - 중복 부분문제 구조 + 최적 부분문제 구조
    - **중복 부분문제 구조** : 문제의 순환적 성질로 이전에 계산된 작은 문제의 해가 더 큰 문제의 해를 구할 때 중복사용
        - 메모이제이션 사용
    - **최적 부분문제 구조** : 주어진 문제가 최적화의 원칙을 만족해야만 효율적으로 적용 가능
        - **최적화 원칙** : 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 함
        - 최장 경로 문제는 최적화 원칙 적용 불가능 → 동적 계획법으로 해결 X
- 분할정복과 다른 점 : **메모이제이션(Memoization)** 사용
    - 분할정복 : 하향식 방법. 주어진 큰 문제를 더 이상 나눌 수 없을 때까지 쪼개서, 작은 문제의 해를 구하고 더 큰 문제를 해결
        - 병합 정렬과 퀵 정렬은 작은 문제의 해가 큰 문제의 해에 중복해서 사용되지 않음
    - **동적계획법** : 상향식 방법. 의존성에 위배되지 않게 작은 문제의 해를 구하여 더 큰 문제의 해를 구함
        - 모든 부분문제를 한 번만 계산 → 결과 저장 → 필요 시 재사용
    - 메모이제이션 : 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행 속도를 빠르게 하는 기술
    
    ```markup
    // memo 배열을 할당, 모두 0으로 초기화
    // memo[0]을 0으로, memo[1]은 1로 초기화
    
    fibo1(n)
    		IF n >= 2 AND memo[n] = 0
    		// memo[n] = 0 이면 처음 계산하는 것
    				memo[n] <- fibo1(n-1) + fibo1(n-2)
    		RETURN memo[n]
    ```
    
    - 메모 배열 : 피보나치 수열의 n번째 값을 저장
        - 피보나치 함수의 매개 변수에 저장되는 0~n까지 값을 메모 배열의 인덱스로 사용
        - 이미 값을 아는 경우(귀납 기본이 되는 n이 0과 1일 경우)에 대한 값을 메모 배열에 저장
        - 나머지는 모두 0으로 초기값 설정
    - 추가 메모리 공간 필요 → n 값이 커질 수록 실행 속도 저하, 스택 오버플로우 발생

### 동적 계획법 적용 방법

1. 최적해 구조의 특성 파악
    1. 문제를 더 작은 부분 문제로 나누어 봄
2. 최적해 값의 재귀적 정의 
    1. 부분 문제들의 최적해를 사용해 더 큰 문제의 최적해 값 정의
    2. 점화식 사용
3. 상향식 방법으로 최적해 값 계산
    1. 의존성에 위배되지 않도록 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장
    2. 테이블에 저장된 부분 문제의 해를 이용해 점차적으로 상위 부분 문제의 최적해를 구함

## 관련 개념 정리

### 1. 수학적 귀납법

- 피보나치 함수의 중복 호출이 얼마나 있는지 알기 위해 이용하는 방법
    - 어떤 등식이 모든 n에 대해서 성립함을 보이기 위해 가능한 모든 n을 등식에 대입하여 증명할 수는 없다
    - 주어진 등식이 n = 1(혹은 n=0)일 때 성립함을 증명 → n일 때 성립한다고 가정 → n+1일 때 성립함을 증명 → 모든 n에 대하여 성립
    - 귀납 기본 → 귀납 가정 → 귀납 단계

### 2. 비둘기 집의 원리

- 비둘기 : n+1마리
- 비둘기 집 : n개
- 각각 임의의 비둘기 집을 선택하여 들어감
- 적어도 한 개의 집에는 2마리 이상의 비둘기 존재
- 귀류법으로 증명

## 문제 풀이

### 1. 타일 채우기

- 조건
    - 2*n 크기의 직사각형을 1*2, 2*1 타일로 채우는 방법의 수
- 풀이
    - 점화식을 세운다 → n-1일 경우와 n-2일 경우
    - D[n-2]에서 D[n-1]에 포함되는 경우는 고려하지 않음
    - D[n] = D[n-1] + D[n-2]
    
    ```java
    public static int dp(int x) {
    		if (x == 1) return 1;
    		if (x == 2) return 2;
    		if (d[x] != 0) return d[x];
    		return d[x] = (dp(x-1) + dp(x-2)) % 10007;
    }
    ```
    

- 조건
    - 2*n 직사각형을 2*1, 2*2 타일로 채우는 방법의 수
- 풀이
    - D[n] = D[n-1] + 2*D[n-2]
    
    ```java
    public static int dp(int x) {
    		if (x == 1) return 1;
    		if (x == 2) return 3;
    		if (d[x] != 0) return d[x];
    		return d[x] = (dp(x-1) + 2*dp(x-2)) % 10007;
    }
    ```
    
- 조건
    - 3*n 크기의 벽을 2*1, 1*2 크기의 타일로 채우는 방법의 수
- 풀이
    - D[n] = 3*D[n-2] 로 생각하면 안됨
    - n-4, n-6 ... 일 경우에는 두가지 경우가 특별하게 더 존재함 → 짝수일 경우 특별한 경우가 존재
    - D[n] = 3*D[n-2] + (2*D[n-4] + 2*D[n-6] + ... + 2*D[0])
    
    ```java
    public static int dp(int x) {
    		if (x == 0) return 1;
    		if (x == 1) return 0;
    		if (x == 1) return 3;
    		if (d[x] != 0) return d[x];
    		int result = 3 * dp(x-2);
    		for (int i = 3; i <= x; i++) {
    				if (i % 2 == 0) {
    						result += 2 * d{x - i);
    				}
    		}
    		return d[x] = result;
    }
    ```
    

- 조건
    - 2*n 크기의 벽을 2*1, 1*2, 1*1 크기의 타일로 채우는 방법의 수
- 풀이
    - D[n] = D[n-1] * 2 + D[n-2] * 3 + (D[n-3] * 2 + D[n-4] * 2 + ... + D[0] * 2)
    
    ```java
    public static int d[1000001];
    
    public static int dp(int x) {
    		if (x == 0) return 1;
    		if (x == 1) return 2;
    		if (x == 1) return 7;
    		if (d[x] != 0) return d[x];
    		int result = 3 * dp(x-2) + 2 * dp(x-1);
    		for (int i = 3; i <= x; i++) {
    				result += (2*dp(x-i)) % 1000000007;
    		}
    		return d[x] = result % 1000000007;
    }
    ```
    
    → 비효율적 알고리즘
    
    - 2차원 다이나믹 프로그래밍 알고리즘을 사용
    
    ```java
    public static long d[1000001][2];
    // 2번째 행은 2씩 고유한 경우의 수가 추가되는 것을 계산하기 위해 사용
    
    public static long dp(int x) {
    		d[0][0] = 0;
    		d[1][0] = 2;
    		d[2][0] = 7;
    		d[2][1] = 1;
    		for (int i = 3; i <= x; i++) {
    				d[i][1] = (d[i-1][1] + d[i-3][0]) % 1000000007;
    				d[i][0] = (3*d[i-2][0] + 2*d[i-1][0] + 2*d[i][1]) % 1000000007;
    		}
    		return d[x][0];
    }
    ```
    

### 2. 피보나치 수

- 조건
    - 첫 달에는 새로 태어난 토끼 한 쌍만 존재
    - 두 달 이상 된 토끼는 번식 가능
    - 번식 가능한 토끼 한 쌍은 매달 새끼 한 쌍을 낳음
    - 토끼는 죽지 않음
- 풀이
    - n번째 달 : a쌍
    - n+1번째 달 : b쌍 (새로 태어난 토끼 포함)
    - n+2번째 달 : a+b쌍
    - f(n+2) = f(n) + f(n+1) → 피보나치 수열
- 재귀함수로 구현할 시 문제점 : 중복이 너무 많이 발생
    
    → 입력값 n에 대한 계산 결과를 저장하면 실행시간을 O(n)으로 줄일 수 있음
    

```markup
fibo_dp(n)
	f[0] <- 0
	f[1] <- 1
	FOR i in 2 -> n
		f[i] <- f[i-1] + f[i-2]
	RETURN f[n]
```

- 피보나치 수 → 동적 계획법 적용 : 재귀 알고리즘 구현에 비해 속도 빠름 (중복 계산이 없기 때문)
    - 재귀 알고리즘 ← 메모이제이션 : 중복 계산을 하지 않지만 여전히 함수 호출 존재
    - 동적 계획법은 반복문 사용으로 함수 호출 발생 X
    - 계산하는 항(f[i])의 총 개수
        - T(n) = n + 1
        - f[0]부터 f[1]까지 단 한번씩만 계산
        

### 3.  동전 거스름돈

- 조건
    - 사용할 수 있는 동전 : 1원, 4원, 6원
    - 거스름돈 8원에 대한 최소 동전 개수는 몇 개?
- 풀이
    - 그리디 접근 방법 : 6원, 1원, 1원
    - 최적해 : 4원, 4원
    - 완전 검색 : 백트래킹을 적용해 가지치기
    - 동적 계획법 적용
- 거스름돈 8원에 대한 재귀적 알고리즘
    - 3가지 동전 각각을 선택해 재귀적으로 해결
        - 1(/4/6)원 동전 한개 + 7(/4/2)원에 대한 최적해
- 상태 공간 트리
    - 세가지 종류의 동전을 하나씩 선택 → 거스름돈이 0원이 되면 하나의 후보해를 찾음
    - 단말 노드를 모두 방문하며 중복 작업
- 재귀 알고리즘에 메모이제이션 적용
    
    ```markup
    // change : 거스름돈 금액, 문제를 나타내는 값
    // coin[COINNUM] = {6, 4, 1} : 동전 종류
    // memo[] : 이미 구한 부분 문제의 해를 저장
    
    CoinChange(change)
    		IF memo[change] != -1
    				RETURN memo[change]
    		IF change = 0
    				RETURN 0
    		ELSE
    				min <- INF
    				FOR i <- 0 TO COINNUM - 1
    					IF change - coin[i] >= 0
    						ret <- coin_change(change-coin[i])
    						// 선택한 동전의 금액 만큼 차감한 금액에 대한 해를 구하기 위해 재귀 호출
    					IF ret < min
    						min = ret
    		memo[change] <- min + 1
    		RETURN memo[change]
    ```
    
- 상향식
    - 1원에 대한 최적해 → ... → 8원에 대한 최적해
    - 거스름돈 금액을 0원부터 1원씩 증가시켜 모든 부분 문제의 해를 구함
    - f(n) = min{f(n-6), f(n-4), f(n-1)} + 1
    
    ```markup
    // change : 거스름돈 금액, 문제를 나타내는 값
    // coin[COINNUM] = {6, 4, 1} : 동전 종류
    // memo[] : 부분 문제의 해를 저장
    
    CoinChange(change)
    		memo[0] = 0
    		FOR N <- 1 TO change
    			min <- INF
    			FOR i <- 1 TO COINNUM - 1// 모든 동전 종류에 대해 반복
    				IF N >= coin[i] // n보다 작은 금액 동전인가?
    				IF memo[N-coin[i]] < min
    				// 현재 선택한 동전의 금액을 차감한 금액에 대한
    				// 해를 가져와서 최소값인지 비교
    				min = memo[N-coin[i]]
    			memo[N] = min + 1
    		RETURN memo[change]
    ```
    

### 4. 이항 계수

- 조건
    - (x+y)^n을 전개했을 때 x^k * y^(n-k)의 계수 값은?
    - 이항계수 구하는 공식
        
        ![Untitled](https://user-images.githubusercontent.com/62470991/151749753-e6d8aee6-3c58-4664-8a4a-9ea3dd1e4281.png)        
    - 파스칼의 삼각형 : 이항 계수를 삼각형 모양의 기하학적 형태로 배열한 것
        - C(n, 0) = 1
        - C(n, n) = 1
        - C(n, k) = C(n-1, k-1) + C(n-1, k), (n > k > 0)
- 풀이
    - 음수가 아닌 정수 n과 k, 여기서 k ≤ n
    
    ```markup
    bino(n, k)
    		IF k = 0 OR n = k
    			RETURN 1
    		ELSE
    			RETURN bino(n-1 ,k-1) + bino(n-1, k)
    ```
    
    → 중복이 너무 많아짐
    
    - 메모이제이션을 이용한 이항 계수의 계산
    
    ```markup
    // B[N][N] : 문제의 해를 저장하기 위한 테이블
    
    B[][] <- {-1}
    bino1(n, r)
    		IF r = 0 OR n = r : RETURN 1
    		IF B[n][r] != -1
    			RETURN B[n][r]
    		B[n][r] <- bino1(n-1, r-1) + bino1(n-1, r)
    		RETURN B[n][r]
    ```
    
    - 동적 계획법을 적용한 이항계수 계산 : O(nk)
    
    ```markup
    bino2(n, k)
    		B[][]
    		FOR i in 0 -> n
    			FOR j in 0 -> minimum(i, k)
    				IF j = 0 OR j = i
    					B[i][j] <- 1
    				ELSE
    					B[i][j] <- B[i-1][j-1] + B[i-1][j]
    		RETURN B[n][k]
    ```